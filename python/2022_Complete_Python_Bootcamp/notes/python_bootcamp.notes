/* notes */


"Section 3: Python Object and Data Structure Basics---{{{

    "12. Python Numbers:---{{{
         integers=whole number
         floats=decimals
         "+","-","*","/"
         "%"=modulus
         "**"=exponents
         follows order of operations (including parenthesis)
         python will automatically convert integer division to a floating point result 
    "}}}
 
    "14. Variable Assignments{{{
         variable_name = <expression>
         cannot start name with a number
         no spaces in the name
         no special characters
         best practice for names in lowercase (unless a global variable)
         avoid python keywords
         python uses dynamic typing allowing you to reassign data types to the same variable
         can result in unexpected data types, the type() function can give you the current data type of the variable
         variable_name=variable_name+<expression>
         type(variable_name)
    "}}}
 
    "15. Introduction to Strings---{{{
          wordybois
          double quotes can enclose single quotes to make them literal and vice versa
          ordered sequences meaning indexing and slicing based on [index]
          base zero indexing
          also allows reverse indexing 0 -n -n+1 -n+2 ... -1
          slicing =  string[start:stop:step] (step defaults to 1 if not given)
          print("string")
          print() takes escape sequences, the standard \[x] values seem to be recognized 
          len(string)=length of string, should work for other arrays as well
    "}}}
     
    "16. Indexing and Slicing with Strings---{{{
        index grabs 1 character
        slicing grabs a range of characters
        string[start:] goes from index [start] to the end of the string
        string[:stop] goes from start of string to [stop] index (non-inclusive)
        all slices given a stop index are non-inclusive of the stop index
        string[::]=the whole string, you will ususally only see this with a step included or else you would just use the whole string without creating a substring
        string[::-1] gives the string in reverse order
    "}}}                

    "17. String Properties and Methods---{{{
        strings are immutable, which means you cannot modify individual indices or substrings once they have been assigned (need to reassign the whole string, or concatenation)
        name=["Sam"]
        new_name="P"+name[1:]
        slicing like this can be done at time of assignment or be read into a variable where they are simply concatenated on a 3rd line
        strings can also be multiplied by [string] * [number] to get the value of that string concatenated to itself [number] of times
        arithmetic with strings like '3' + '2' concatenates the strings, casting operators would be useful if you are explicitly expecting ints
        help(str) gives you all methods, methods with __[name]__ actually need the preceeding and trailing underscores to be executed
    "}}}

    "19 Print formatting with Strings---{{{ 
        multiple ways to format strings with variables in them, known as string interpolation
        using the .format() method and .fstring() method
        print('words here {} then also {}'.format('var1','var2'))
        this seems to be a derivation of the printf syntax that originates with C (but also shows up in bash, awk, etc)
        you can put index numbers inside of the {} in the print statement and use indicies of the arguments given to put them in any order (this is behavior lecagy printf cannot do)
        print('The {2} {1} {0}').format('fox','brown','quick') = 'The quick brown fox'
        the indices can be repeated multiple times each (or never used at all)
        the arguments can also be given keywords that make more sense
        print('The {q} {b} {f}').format(f='fox',b='brown',q='quick') = 'The quick brown fox'
        float formatting with .format allows you to specify width and precision of floating point numbers
        syntax is {value:width.precision f}
        result=100/777
        print("the result was {r:1.3f}.format(r=result))
        the width value only really adds whitespace to the front of the string, can be useful for aligning columns in the output
        fstrings=introduced in 3.6
        name = "jose"
        print(f'Hello, his name is {name}')
        seems to be better than the format method and can make it easier to read/write
    "}}}     
     
    "21. Lists in Python---{{{    
        list_name = [value1,value2,value3]
        lists can be of mixed object/data types
        supports indexing and slicing in exactly the way(s) strings do
        lists can be concatenated together
        list values are mutable so you can reassign elements in the sme list without reassigning the whole list or creating a new list
        list.append(value) = adds new element to the end of a list
        list.pop() pops the last element from the list and also returns that value
        list.pop(index) pops the item at the specified index
        list.remove(value)=removes the first occurance of [value]
        list.sort()=sorts list according to some type of ordering (alphabetical, numberic, etc) *IN PLACE*
        list.sort()= sorts in "ascending" order by default but can be given extra parameters to change this behavior
        list.reverse()=reverses list *IN PLACE*
        NULL in python is defined as None
    "}}} 
            
    "23. Dictionaries in Python---{{{ 
        unordered mappings of key-value pairs
        allows you to quickly grab a value without caring about an index location
        syntax:my_dict = {'key1':'value1':'key2':'value2'...}
        my_dict['key1'] retrieves the value of key1
        cannot be sorted, indexed, or sliced; use when you want values and don't care about indicies
        you can space a dictionary across multiple lines:
        my_dict={'key1':value1,
                 'key2':value2,
        }
        it does not seem ot care about indentation like most python control structures do, probably because of the actual delimiting {} in this case
        other data structures can be the values in key-value pairs (including other dictionaries)
        if referencing nested datastructures, simply use dict_name[key1][key/index of key1 value]
        you can add elements by just saying my_dict['new_key'] = new_value (this can also be used to overwrite existing key values)
        methods: dict.keys()=shows all keys; dict.values()=get all values; dict.items()=returns all key-value pairs (they are returned as tuples)
    "}}}
        
         


        


"}}}

*args and **kwargs are used to refer to the arguments sent to functions
"Section 5: Functions, loops, etc---{{{
"Lambda Expressions, Map, Filter---{{{
    map(function,data):
        can be used to apply a function to an iterable set of data without writing a formal loop{
            for item in map(<function_name>,<data_structure):
                print(item)
           list(map(<function>,<data_structure>)) will return the output as a list you can use
           you do not use the () for the function call as map will execute the function name you provide it 

   filter(function,data):{
       will return such items in data for which the function returns True for that item (obvously only works with functions that return booleans)

  Lambda Expressions{ (also known as anonymous function)
      original function:{
          def square(num):
            result = num**2
            return result
        }
        Lambda Version:
            lambda num: num ** 2
            square = lambda num: num**2
            square(5) gives 25
  }
  Combining all three:{
      list(map(lambda num:num**2,mynums))
      results in a list of the items in the mynums list squared via the lambda expression

      list(map(lambda num: num%2 == 0,my_nums)) 
      returns a list of even numbers provided via the my_nums function

      list(map(lambda name:name[0],names))
  }
}
   
"}}}


"Nested Statements and Scope---{{{

    variables assigned in a function are local by default

    LEGB Rule:
        L - Local - names assigned in a function or lambda (not declared global in function)
        E - Enclosing function locals - names in the local scope of any and all enclosing (nested) functions (def or lambda) from inner to outer (ie if not in local function but in direct parent, then chooses taht, even if its parent has a variable of the same name)
        G - Global (module) - Names assigned at the top level of a module file or declared global in a def within the file
        B: Builtin (Python) - Names preassigned in the builtin names module : open,range,SyntaxError,etc


        global variables can have their values changed within a function after they are instantiated with the global keyword:{
            x = 50
            def func()
                global x
                x = 200
           print(x) => yields 200 because global x was modified after declared within the function
           # the global keyword is only necessary if you want to either instantiate a global variable or assign a value to an existing once
           # you can reference the value of global variables like you would any local variable as log as a local variable of the same name does not exist
        }






"}}}

"}}}

"Object Oriented Programming---{{{

    "Attrubutes and class keyword---{{{
    type() builtin funciton gives object/data types
    Syntax:{
        class ClassName():
            def __init__(self,param1,Param2):
                self.param1 = param1
                self.param2 = param2 # Allows you to refer to properties by <instance>.<property_name>
            def some_method(self):
                #actions
                print(self.param1)
     }

     class Dog():

        def __init__(self,size,breed,sex,age): # Constructor for class, called automatically on instance creation
                                               # Self keyword refers to this specific instance of the class
                                               # the variables passed into the constructor function are technically different than the self.<attribute_name> values, but convention is to use the same name
            self.breed = str(breed) 
            self.size = float(size)
            self.sex = str(sex)
            self.age = int(age)
    "}}}
        
   "Class Objects---{{{ 


     class Dog():
        #Class object attributes defined here (before init method)
        # These are attributes that are the same for all instances of this class
        # they can be referenced internally by self.attribute or by <ClassName>.attribute 
        # For attributes that will change their values or are specific to an instance of a class, use the self.attribute = <value> in the init method 

        biological_kingdom = 'animal'
        biological_phylum = 'chordata'
        biological_class = 'mammal'
        biological_order = 'carnivora'
        biological_family = 'canidae'
        biolobical_genus = 'canis'
        biological_species = 'canis familiaris'
        has_barked = False

        def __init__(self,size,breed,sex,age):
            self.breed = str(breed) 
            self.size = float(size)
            self.sex = str(sex)
            self.age = int(age)

        #Methods: Functions but for instances of a class
        def bark(self, number):
            for bork in range(0,number):
                print("bork")
            self.has_barked = True # Self keyword necessary to modify attributes of self (this is also true if passing in an existing attribute of this instance)
        



    "}}}
   

    "Inheritance and polymorphism---{{{

        Inheritance:
            # way to form new classes using classes that have already been defined
            
            class Animal():
                def __init__(self):
                    print("Animal Created")
                def who_am_i(self):
                    print("I am an animal")
                def eat(self)
                    print("I am eating")
            
            class Dog(Animal):
                def __init__(self):
                    Animal.__init__(self)
                    print("Dog Created")
                    # This dog class now inherits all methods of the animal class 
                def who_am_i(self):
                    print("I am a Dog")
                    #overwrites inhereted who_am_i method
                def bark(self):
                    print('WOOF')
                    #adds extra method not available to the animal class
        
        Polymorphism:
            # different object classes can share the same method name
            # The methods can then be called from the same place even though a variety of objects may be passed down to it

            class Dog():
                def __init__(self,name):
                    self.name = name
                def speak(self):
                    return f'{self.name} says woof!'

            class Cat():
                def __init__(self,name):
                    self.name = name
                def speak(self):
                    return f'{self.name} says meow!'
            
            niko = Dog('niko')
            felix = Cat('felix')
            niko.speak() # niko says woof!
            felix.speak() # felix says meow!

            for pet_class in [felix,niko]:
            print(type(pet_class))  
            print(pet_class.speak())

            def pet_speak(pet):
                print(pet.speak())

            # basically as long as a method name is shared between classes, no matter how different, they can be programatically referenced and called in generic ways via functions and loops 

        Abstract Classes:
            # These are designed to never be instantiated directly but only to server as a base templace class for a more specific implementation that is expected to be instantiated 
            class Animal(): # the syntax and implementation are not actually different from a normal class, its jus tin how you use/intend to use them
                def __init__(self,name):
                    self.name = name
                def speak(self):
                raise NotImplementedError("Subclass must implement this abstract method") 

            class Dog(Animal):
                def speak(self): # notice that you didn't need to call the init method if you don't want ot change anything form the abstract class
                    return f'{self.name} says woof!'

   "}}}    

    
        "Special(magic/dunder) methods---{{{

            # allow you to use some builtin funcitons of python with your own methods
            mylist = [1,2,3]
            len(mylist)
            class Sample():
                pass 
            
            mysample = Sample()
            len(mysample) # raises error
            print(mysample) # prints memory location of sample object instance

            class Book():
                def __init__(self, title, author, pages): 
                    self.title = title
                    self.author = author 
                    self.pages = pages 
                def __str__(self): # this is the method that is ran any time something asks for the string representation of our class
                    return f'{self.title} by {self.author} is {pages} long'
                def __len__(self)
                    return self.pages
                def __del__(self):
                    # executes upon instance deletion
                    print(f'Book object with title {self.title} has been deleted')
            
            b = Book('Python rocks', 'jose', 200)
            print(b) # the print function attempts to print the string representition of the book object 'b', and thus the __str__(self) method is invoked 
            len(b) # returns length of pages
            del b # deletes this object from the memory

        "}}}









